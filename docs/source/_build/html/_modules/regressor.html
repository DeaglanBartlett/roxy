

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>regressor &mdash; roxy 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=d45e8c67"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            roxy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">roxy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Module code</a></li>
      <li class="breadcrumb-item active">regressor</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for regressor</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">jax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpyro</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpyro.distributions</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dist</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.mixture</span><span class="w"> </span><span class="kn">import</span> <span class="n">GaussianMixture</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">attrgetter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">jaxopt</span><span class="w"> </span><span class="kn">import</span> <span class="n">ScipyBoundedMinimize</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">roxy.likelihoods</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">roxy.mcmc</span>


<div class="viewcode-block" id="OptResult">
<a class="viewcode-back" href="../api.html#regressor.OptResult">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">OptResult</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to make the output of a jaxopt optimisation appear like</span>
<span class="sd">    a scipy.optimize._optimize.OptimizeResult</span>

<span class="sd">    Args:</span>
<span class="sd">        :res (ScipyMinimizeInfo): The result of a jaxopt minimisation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">success</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">success</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">status</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fun</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">fun_val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jac</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hess</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hess_inv</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">hess_inv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">njev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nhev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nit</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">iter_num</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxcv</span> <span class="o">=</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="RoxyRegressor">
<a class="viewcode-back" href="../api.html#regressor.RoxyRegressor">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RoxyRegressor</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Regressor class which handles optimisation and MCMC for ``roxy``. One can</span>
<span class="sd">    use this class to evaluate the function of interest and its derivative,</span>
<span class="sd">    optimise the parameters using and of the defined likelihoods and run an</span>
<span class="sd">    MCMC for these parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        :fun (callable): The function, f, to be considered by this regressor</span>
<span class="sd">            y = f(x, theta). The function must take two arguments, the first of which</span>
<span class="sd">            is the independent variable, the second of which are the parameters (as an</span>
<span class="sd">            array or list).</span>
<span class="sd">        :param_names (list): The list of parameter names, in the order which they are</span>
<span class="sd">            supplied to fun</span>
<span class="sd">        :param_default (list): The default valus of the parameters</span>
<span class="sd">        :param_prior (dict): The prior range for each of the parameters. The prior is</span>
<span class="sd">            assumed to be uniform in this range. If either entry is None in the prior,</span>
<span class="sd">            then an infinite uniform prior is assumed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">param_default</span><span class="p">,</span> <span class="n">param_prior</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">single_fun</span> <span class="o">=</span> <span class="n">fun</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">single_gradfun</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">single_fun</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">single_secondgradfun</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">single_gradfun</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fun</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">single_fun</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gradfun</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">single_gradfun</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">secondgradfun</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">single_secondgradfun</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="n">param_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_default</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">param_default</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span> <span class="o">=</span> <span class="n">param_prior</span>

<div class="viewcode-block" id="RoxyRegressor.value">
<a class="viewcode-back" href="../api.html#regressor.RoxyRegressor.value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If we are fitting the function f(x, theta), this is f(x, theta) evaluated at</span>
<span class="sd">        (x, theta)</span>

<span class="sd">        Args:</span>
<span class="sd">            :x (jnp.ndarray): The x values</span>
<span class="sd">            :theta (jnp.ndarray): The parameter values</span>

<span class="sd">        Returns:</span>
<span class="sd">            :jnp.ndarray: f(x, theta) evaluated at (x, theta)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="RoxyRegressor.gradient">
<a class="viewcode-back" href="../api.html#regressor.RoxyRegressor.gradient">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If we are fitting the function f(x, theta), this is df/dx evaluated at</span>
<span class="sd">        (x, theta)</span>

<span class="sd">        Args:</span>
<span class="sd">            :x (jnp.ndarray): The x values</span>
<span class="sd">            :theta (jnp.ndarray): The parameter values</span>

<span class="sd">        Returns:</span>
<span class="sd">            :jnp.ndarray: df/dx evaluated at (x, theta)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradfun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="RoxyRegressor.second_derivative">
<a class="viewcode-back" href="../api.html#regressor.RoxyRegressor.second_derivative">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">second_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If we are fitting the function f(x, theta), this is d^2f/dx^2 evaluated at</span>
<span class="sd">        (x, theta)</span>

<span class="sd">        Args:</span>
<span class="sd">            :x (jnp.ndarray): The x values</span>
<span class="sd">            :theta (jnp.ndarray): The parameter values</span>

<span class="sd">        Returns:</span>
<span class="sd">            :jnp.ndarray: d^2f/dx^2 evaluated at (x, theta)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">secondgradfun</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="RoxyRegressor.negloglike">
<a class="viewcode-back" href="../api.html#regressor.RoxyRegressor.negloglike">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">negloglike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">y_is_detected</span><span class="o">=</span><span class="p">[],</span> <span class="n">sig</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">mu_gauss</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">w_gauss</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>
                   <span class="n">weights_gauss</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mnr&#39;</span><span class="p">,</span> <span class="n">covmat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">test_prior</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">include_logdet</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the negative log-likelihood under the assumption of</span>
<span class="sd">        an uncorrelated (correlated) Gaussian likelihood if covmat is False (True),</span>
<span class="sd">        using the likelihood specififed by &#39;method&#39;.</span>

<span class="sd">        Args:</span>
<span class="sd">            :theta (jnp.ndarray): The parameters of the function to use</span>
<span class="sd">            :xobs (jnp.ndarray): The observed x values</span>
<span class="sd">            :yobs (jnp.ndarray): The observed y values</span>
<span class="sd">            :errors (jnp.ndarray): If covmat=False, then this is [xerr, yerr], giving</span>
<span class="sd">                the error on the observed x and y values. Otherwise, this is the</span>
<span class="sd">                covariance matrix in the order (x, y)</span>
<span class="sd">            :y_is_detected (jnp.ndarray): A boolean array of the same length as xobs </span>
<span class="sd">                and yobs, giving whether each point is a detection (True) or an upper </span>
<span class="sd">                limit (False)</span>
<span class="sd">            :sig (float, default=0.): The intrinsic scatter, which is added in</span>
<span class="sd">                quadrature with yerr</span>
<span class="sd">            :mu_gauss (float or jnp.ndarray, default=0.): The mean of the Gaussian</span>
<span class="sd">                prior on the true x positions (only used if method=&#39;mnr&#39; or &#39;gmm&#39;).</span>
<span class="sd">                If using &#39;mnr&#39; and this is an array, only the first mean is used.</span>
<span class="sd">            :w_gauss (float or jnp.ndarray, default=1.): The standard deviation of the</span>
<span class="sd">                Gaussian prior on the true x positions (only used if method=&#39;mnr&#39;).</span>
<span class="sd">            :weights_gauss (float or jnp.ndarray, default=1.): The weights of the</span>
<span class="sd">                Gaussians in a GMM prior on the true x positions (only used if</span>
<span class="sd">                method=&#39;gmm&#39;).</span>
<span class="sd">            :method (str, default=&#39;mnr&#39;): The name of the likelihood method to use</span>
<span class="sd">                (&#39;mnr&#39;, &#39;gmm&#39;, &#39;unif&#39; or &#39;prof&#39;). See ``roxy.likelihoods`` for more</span>
<span class="sd">                information</span>
<span class="sd">            :covmat (bool, default=False): This determines whether the errors argument</span>
<span class="sd">                is [xerr, yerr] (False) or a covariance matrix (True).</span>
<span class="sd">            :test_prior (bool, default=True): Whether to test sigma &gt;= 0 and Gaussians</span>
<span class="sd">                weights &gt;= 0</span>
<span class="sd">            :include_logdet (bool, default=True): For the method &#39;prof&#39;, whether to</span>
<span class="sd">                include the normalisation term in the likelihood proportional</span>
<span class="sd">                to log(det(S))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fun</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">)(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fprime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span> <span class="o">=</span> <span class="n">errors</span>

        <span class="k">if</span> <span class="n">test_prior</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sig</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="p">(</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mnr&#39;</span> <span class="ow">and</span> <span class="n">w_gauss</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mnr&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                <span class="k">return</span> <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">negloglike_mnr_mv</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span>
                                                          <span class="n">mu_gauss</span><span class="p">,</span> <span class="n">w_gauss</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">negloglike_mnr_uplims</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">y_is_detected</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                                                                  <span class="n">fprime</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">mu_gauss</span><span class="p">,</span> <span class="n">w_gauss</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">negloglike_mnr</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                                                       <span class="n">fprime</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">mu_gauss</span><span class="p">,</span> <span class="n">w_gauss</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gmm&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mu_gauss</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">w_gauss</span><span class="p">)</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">weights_gauss</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">negloglike_gmm</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                                                       <span class="n">fprime</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;unif&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">negloglike_unif_mv</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span>
                                                           <span class="n">sig</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">negloglike_unif</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                                                        <span class="n">fprime</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;prof&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>
            <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">negloglike_prof_mv</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span>
                                                           <span class="n">sig</span><span class="p">,</span> <span class="n">include_logdet</span><span class="o">=</span><span class="n">include_logdet</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">negloglike_prof</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                                                        <span class="n">fprime</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">include_logdet</span><span class="o">=</span><span class="n">include_logdet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="RoxyRegressor.get_param_index">
<a class="viewcode-back" href="../api.html#regressor.RoxyRegressor.get_param_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_param_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params_to_opt</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the function of interest if f(x, theta), find the index in theta for each</span>
<span class="sd">        of the parameters we wish to optimise</span>

<span class="sd">        Args:</span>
<span class="sd">            :params_to_opt (list): The names of the parameters we wish to optimise</span>
<span class="sd">            :verbose (bool, default=True): Whether to print the names and values of</span>
<span class="sd">                parameters which are not fitted</span>

<span class="sd">        Returns:</span>
<span class="sd">            :pidx (jnp.ndarray): The indices of the parameters to optimise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get indices of params to optimise</span>
        <span class="n">pidx</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params_to_opt</span> <span class="k">if</span>
                <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pidx</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span> <span class="ow">and</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Not optimising all parameters. Using defaults:&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">pname</span><span class="p">,</span> <span class="n">pdefault</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_default</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">pname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">params_to_opt</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pname</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">pdefault</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pidx</span><span class="p">)</span></div>


<div class="viewcode-block" id="RoxyRegressor.optimise">
<a class="viewcode-back" href="../api.html#regressor.RoxyRegressor.optimise">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params_to_opt</span><span class="p">,</span> <span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">y_is_detected</span><span class="o">=</span><span class="p">[],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mnr&#39;</span><span class="p">,</span>
                 <span class="n">infer_intrinsic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ngauss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">covmat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">gmm_prior</span><span class="o">=</span><span class="s1">&#39;hierarchical&#39;</span><span class="p">,</span> <span class="n">include_logdet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">optimiser</span><span class="o">=</span><span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimise the parameters of the function given some data, under the assumption of</span>
<span class="sd">        an uncorrelated (correlated) Gaussian likelihood if covmat is False (True),</span>
<span class="sd">        using the likelihood specififed by &#39;method&#39;.</span>

<span class="sd">        Args:</span>
<span class="sd">            :params_to_opt (list): The names of the parameters we wish to optimise</span>
<span class="sd">            :xobs (jnp.ndarray): The observed x values</span>
<span class="sd">            :yobs (jnp.ndarray): The observed y values</span>
<span class="sd">            :errors (jnp.ndarray): If covmat=False, then this is [xerr, yerr], giving</span>
<span class="sd">                the error on the observed x and y values. Otherwise, this is the</span>
<span class="sd">                covariance matrix in the order (x, y)</span>
<span class="sd">            :y_is_detected (jnp.ndarray): A boolean array of the same length as xobs </span>
<span class="sd">                and yobs, giving whether each point is a detection (True) or an upper </span>
<span class="sd">                limit (False)</span>
<span class="sd">            :method (str, default=&#39;mnr&#39;): The name of the likelihood method to use</span>
<span class="sd">                (&#39;mnr&#39;, &#39;gmm&#39;, &#39;unif&#39; or &#39;prof&#39;). See ``roxy.likelihoods`` for more</span>
<span class="sd">                information</span>
<span class="sd">            :infer_intrinsic (bool, default=True): Whether to infer the intrinsic</span>
<span class="sd">                scatter in the y direction</span>
<span class="sd">            :initial (jnp.ndarray, default=None): The starting point for the optimised.</span>
<span class="sd">                If None, a random value in the prior range is chosen</span>
<span class="sd">            :ngauss (int, default = 1): The number of Gaussians to use in the GMM prior.</span>
<span class="sd">                Only used if method=&#39;gmm&#39;</span>
<span class="sd">            :covmat (bool, default=False): This determines whether the errors argument</span>
<span class="sd">                is [xerr, yerr] (False) or a covariance matrix (True).</span>
<span class="sd">            :gmm_prior (string, default=&#39;hierarchical&#39;): If method=&#39;gmm&#39;, this decides</span>
<span class="sd">                what prior to put on the GMM componenents. If &#39;uniform&#39;, then the mean</span>
<span class="sd">                and widths have a uniform prior, and if &#39;hierarchical&#39; mu and w^2 have</span>
<span class="sd">                a Normal and Inverse Gamma prior, respectively.</span>
<span class="sd">            :include_logdet (bool, default=True): For the method &#39;prof&#39;, whether to</span>
<span class="sd">                include the normalisation term in the likelihood proportional</span>
<span class="sd">                to log(det(S))</span>
<span class="sd">            :verbose (bool, default=True): Whether to print progress or not</span>
<span class="sd">            :optimiser (str, default=&#39;l-bfgs-b&#39;): The optimiser to use. This must be a</span>
<span class="sd">                method supported by jaxopt.ScipyBoundedMinimize.</span>


<span class="sd">        Returns:</span>
<span class="sd">            :res (OptResult): The result of the optimisation</span>
<span class="sd">            :param_names (list): List of parameter names in order of res.params</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check whether y_is_detected is either [] or an array of booleans the same length as xobs and yobs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="ow">or</span>
            <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jax</span><span class="o">.</span><span class="n">Array</span><span class="p">))</span>
                <span class="ow">and</span> <span class="n">y_is_detected</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">xobs</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;y_is_detected must be either an empty list or a boolean array &quot;</span>
                <span class="s2">&quot;of the same length as xobs and yobs&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Check if warning should be raised</span>
        <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">likelihood_warnings</span><span class="p">(</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">infer_intrinsic</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xobs</span><span class="p">),</span> <span class="n">errors</span><span class="p">,</span> <span class="n">covmat</span><span class="p">)</span>

        <span class="c1"># Get indices of params to optimise</span>
        <span class="n">pidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_param_index</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">fopt</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>

            <span class="n">bad_run</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Parameters of function</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_default</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">theta</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">pidx</span><span class="p">)])</span>

            <span class="c1"># Â Intrinsic scatter</span>
            <span class="k">if</span> <span class="n">infer_intrinsic</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pidx</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="c1"># Variable to store any prior knowledge</span>
            <span class="n">nll</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="c1"># MNR parameters</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mnr&#39;</span><span class="p">:</span>
                <span class="n">mu_gauss</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">w_gauss</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">weights_gauss</span> <span class="o">=</span> <span class="mf">1.</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gmm&#39;</span><span class="p">:</span>
                <span class="n">imin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">infer_intrinsic</span><span class="p">:</span>
                    <span class="n">imin</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">mu_gauss</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">imin</span><span class="p">:</span><span class="n">imin</span><span class="o">+</span><span class="n">ngauss</span><span class="p">]</span>
                <span class="n">w_gauss</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="n">ngauss</span><span class="p">:</span><span class="n">imin</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">ngauss</span><span class="p">]</span>
                <span class="n">weights_gauss</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ngauss</span><span class="p">)</span>
                <span class="n">weights_gauss</span> <span class="o">=</span> <span class="n">weights_gauss</span><span class="o">.</span><span class="n">at</span><span class="p">[:</span><span class="n">ngauss</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                    <span class="n">theta</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">ngauss</span><span class="p">:</span><span class="n">imin</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">ngauss</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">weights_gauss</span> <span class="o">=</span> <span class="n">weights_gauss</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                    <span class="mi">1</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights_gauss</span><span class="p">))</span>

                <span class="n">bad_run</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">weights_gauss</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">jnp</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                    <span class="n">weights_gauss</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">gmm_prior</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">gmm_prior</span> <span class="o">==</span> <span class="s1">&#39;hierarchical&#39;</span><span class="p">:</span>
                    <span class="n">hyper_mu</span><span class="p">,</span> <span class="n">hyper_w2</span><span class="p">,</span> <span class="n">hyper_u2</span> <span class="o">=</span> <span class="n">theta</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">ngauss</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">nll</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hyper_w2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hyper_u2</span><span class="p">)</span>
                               <span class="o">+</span> <span class="n">hyper_w2</span> <span class="o">/</span> <span class="n">hyper_u2</span><span class="p">)</span>
                        <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                            <span class="mf">0.5</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hyper_u2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">w_gauss</span><span class="p">)</span>
                            <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hyper_w2</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                            <span class="o">+</span> <span class="p">(</span><span class="n">mu_gauss</span> <span class="o">-</span> <span class="n">hyper_mu</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">hyper_w2</span><span class="p">)</span>
                            <span class="o">+</span> <span class="n">hyper_w2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">w_gauss</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mu_gauss</span><span class="p">,</span> <span class="n">w_gauss</span><span class="p">,</span> <span class="n">weights_gauss</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

            <span class="n">ll</span> <span class="o">=</span> <span class="n">nll</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">negloglike</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="n">sig</span><span class="p">,</span>
                                       <span class="n">mu_gauss</span><span class="o">=</span><span class="n">mu_gauss</span><span class="p">,</span> <span class="n">w_gauss</span><span class="o">=</span><span class="n">w_gauss</span><span class="p">,</span> <span class="n">weights_gauss</span><span class="o">=</span><span class="n">weights_gauss</span><span class="p">,</span> <span class="n">y_is_detected</span><span class="o">=</span><span class="n">y_is_detected</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">covmat</span><span class="o">=</span><span class="n">covmat</span><span class="p">,</span> <span class="n">test_prior</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">include_logdet</span><span class="o">=</span><span class="n">include_logdet</span><span class="p">)</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">bad_run</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">ll</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">ll</span>

        <span class="c1"># Â Get initial guess</span>
        <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">initial</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
                    <span class="n">initial</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">initial</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">infer_intrinsic</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
                    <span class="n">initial</span> <span class="o">=</span> <span class="n">initial</span> <span class="o">+</span> \
                        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">])]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">initial</span> <span class="o">=</span> <span class="n">initial</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mnr&#39;</span><span class="p">:</span>
                <span class="n">initial</span> <span class="o">=</span> <span class="n">initial</span> <span class="o">+</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">xobs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">xobs</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gmm&#39;</span><span class="p">:</span>
                <span class="n">gm</span> <span class="o">=</span> <span class="n">GaussianMixture</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="n">ngauss</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
                    <span class="n">xobs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">gm_means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">means_</span><span class="p">))</span>
                <span class="n">gm_ws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">covariances_</span><span class="p">)))</span>
                <span class="n">gm_weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">gm</span><span class="o">.</span><span class="n">weights_</span><span class="p">))</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">gm_means</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">gmm_prior</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
                    <span class="n">initial</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="n">initial</span>
                        <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">gm_means</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                        <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">gm_ws</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                        <span class="o">+</span> <span class="nb">list</span><span class="p">((</span><span class="n">gm_weights</span><span class="p">[</span><span class="n">idx</span><span class="p">])[:</span><span class="n">ngauss</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">gmm_prior</span> <span class="o">==</span> <span class="s1">&#39;hierarchical&#39;</span><span class="p">:</span>
                    <span class="n">initial</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="n">initial</span>
                        <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">gm_means</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                        <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">gm_ws</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                        <span class="o">+</span> <span class="nb">list</span><span class="p">((</span><span class="n">gm_weights</span><span class="p">[</span><span class="n">idx</span><span class="p">])[:</span><span class="n">ngauss</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="o">+</span> <span class="p">[</span><span class="n">gm_means</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">gm_ws</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">gm_ws</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="n">initial</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="n">scipy_opt</span> <span class="o">=</span> <span class="n">ScipyBoundedMinimize</span><span class="p">(</span><span class="n">fun</span><span class="o">=</span><span class="n">fopt</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">optimiser</span><span class="p">)</span>
        <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
                <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">lower_bounds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">upper_bounds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">infer_intrinsic</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
                <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">lower_bounds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pidx</span><span class="p">)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">upper_bounds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pidx</span><span class="p">)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">lower_bounds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">pidx</span><span class="p">)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gmm&#39;</span><span class="p">:</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">infer_intrinsic</span><span class="p">:</span>
                <span class="n">imin</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Widths</span>
            <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">lower_bounds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="n">ngauss</span><span class="p">:</span><span class="n">imin</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">ngauss</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
            <span class="c1"># Weights</span>
            <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">lower_bounds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">imin</span> <span class="o">+</span>
                                           <span class="mi">2</span><span class="o">*</span><span class="n">ngauss</span><span class="p">:</span><span class="n">imin</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">ngauss</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
            <span class="n">upper_bounds</span> <span class="o">=</span> <span class="n">upper_bounds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">imin</span> <span class="o">+</span>
                                           <span class="mi">2</span><span class="o">*</span><span class="n">ngauss</span><span class="p">:</span><span class="n">imin</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">ngauss</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
            <span class="c1"># Hierarchical params</span>
            <span class="n">lower_bounds</span> <span class="o">=</span> <span class="n">lower_bounds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">ngauss</span><span class="p">:]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">scipy_opt</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">initial</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="n">lower_bounds</span><span class="p">,</span> <span class="n">upper_bounds</span><span class="p">))</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">OptResult</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

        <span class="c1"># Â Print results</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Optimisation Results:&#39;</span><span class="p">)</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">,</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">infer_intrinsic</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sig:</span><span class="se">\t</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">)]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;sig&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mnr&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mu_gauss:</span><span class="se">\t</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;w_gauss:</span><span class="se">\t</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;mu_gauss&#39;</span><span class="p">)</span>
            <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;w_gauss&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gmm&#39;</span><span class="p">:</span>
            <span class="n">imin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">infer_intrinsic</span><span class="p">:</span>
                <span class="n">imin</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngauss</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mu_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mu_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngauss</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;w_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="n">ngauss</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;w_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngauss</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;weight_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">ngauss</span><span class="o">+</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;weight_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">gmm_prior</span> <span class="o">==</span> <span class="s1">&#39;hierarchical&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;hyper_mu:</span><span class="se">\t</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">ngauss</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;hyper_u2:</span><span class="se">\t</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">ngauss</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;hyper_w2:</span><span class="se">\t</span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="n">imin</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="n">ngauss</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;hyper_mu&#39;</span><span class="p">)</span>
                <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;hyper_w2&#39;</span><span class="p">)</span>
                <span class="n">param_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;hyper_u2&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">,</span> <span class="n">param_names</span></div>


<div class="viewcode-block" id="RoxyRegressor.mcmc">
<a class="viewcode-back" href="../api.html#regressor.RoxyRegressor.mcmc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mcmc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params_to_opt</span><span class="p">,</span> <span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span>  <span class="n">errors</span><span class="p">,</span> <span class="n">nwarm</span><span class="p">,</span> <span class="n">nsamp</span><span class="p">,</span> <span class="n">y_is_detected</span><span class="o">=</span><span class="p">[],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mnr&#39;</span><span class="p">,</span>
             <span class="n">ngauss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">infer_intrinsic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_chains</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">covmat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">gmm_prior</span><span class="o">=</span><span class="s1">&#39;hierarchical&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">include_logdet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimiser</span><span class="o">=</span><span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run an MCMC using the NUTS sampler of ``numpyro`` for the parameters of the</span>
<span class="sd">        function given some data, under the assumption of an uncorrelated Gaussian</span>
<span class="sd">        likelihood, using the likelihood specififed by &#39;method&#39;.</span>

<span class="sd">        Args:</span>
<span class="sd">            :params_to_opt (list): The names of the parameters we wish to optimise</span>
<span class="sd">            :xobs (jnp.ndarray): The observed x values</span>
<span class="sd">            :yobs (jnp.ndarray): The observed y values</span>
<span class="sd">            :errors (jnp.ndarray): If covmat=False, then this is [xerr, yerr], giving</span>
<span class="sd">                the error on the observed x and y values. Otherwise, this is the</span>
<span class="sd">                covariance matrix in the order (x, y)</span>
<span class="sd">            :nwarm (int): The number of warmup steps to use in the MCMC</span>
<span class="sd">            :nsamp (int): The number of samples to obtain in the MCMC</span>
<span class="sd">            :y_is_detected (jnp.ndarray): A boolean array of the same length as xobs </span>
<span class="sd">                and yobs, giving whether each point is a detection (True) or an upper </span>
<span class="sd">                limit (False).</span>
<span class="sd">            :method (str, default=&#39;mnr&#39;): The name of the likelihood method to use</span>
<span class="sd">                (&#39;mnr&#39;, &#39;gmm&#39;, &#39;unif&#39; or &#39;prof&#39;). See ``roxy.likelihoods`` for more</span>
<span class="sd">                information.</span>
<span class="sd">            :ngauss (int, default = 1): The number of Gaussians to use in the GMM prior.</span>
<span class="sd">                Only used if method=&#39;gmm&#39;</span>
<span class="sd">            :infer_intrinsic (bool, default=True): Whether to infer the intrinsic</span>
<span class="sd">                scatter in the y direction</span>
<span class="sd">            :num_chains (int, default=1): The number of independent MCMC chains to run</span>
<span class="sd">            :progress_bar (bool, default=True): Whether to display a progress bar for</span>
<span class="sd">                the MCMC</span>
<span class="sd">            :covmat (bool, default=False): This determines whether the errors argument</span>
<span class="sd">                is [xerr, yerr] (False) or a covariance matrix (True).</span>
<span class="sd">            :gmm_prior (string, default=&#39;hierarchical&#39;): If method=&#39;gmm&#39;, this decides</span>
<span class="sd">                what prior to put on the GMM componenents. If &#39;uniform&#39;, then the mean</span>
<span class="sd">                and widths have a uniform prior, and if &#39;hierarchical&#39; mu and w^2 have a</span>
<span class="sd">                Normal and Inverse Gamma prior, respectively.</span>
<span class="sd">            :seed (int, default=1234): The seed to use when initialising the sampler</span>
<span class="sd">            :verbose (bool, default=True): Whether to print progress or not</span>
<span class="sd">            :init (dict, default=None): A dictionary of values of initialise the MCMC at</span>
<span class="sd">            :include_logdet (bool, default=True): For the method &#39;prof&#39;, whether to</span>
<span class="sd">                include the normalisation term in the likelihood proportional</span>
<span class="sd">                to log(det(S))</span>
<span class="sd">            :optimiser (str, default=&#39;l-bfgs-b&#39;): The optimiser to use if a initial</span>
<span class="sd">                point is not specified. This must be a method supported by</span>
<span class="sd">                jaxopt.ScipyBoundedMinimize.</span>
<span class="sd">        Returns:</span>
<span class="sd">            :samples (dict): The MCMC samples, where the keys are the parameter names</span>
<span class="sd">                and values are ndarrays of the samples</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if warning should be raised</span>
        <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">likelihood_warnings</span><span class="p">(</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">infer_intrinsic</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xobs</span><span class="p">),</span> <span class="n">errors</span><span class="p">,</span> <span class="n">covmat</span><span class="p">)</span>

        <span class="n">pidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_param_index</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xobs</span><span class="p">)</span>
            <span class="n">Sxx</span> <span class="o">=</span> <span class="n">errors</span><span class="p">[:</span><span class="n">nx</span><span class="p">,</span> <span class="p">:</span><span class="n">nx</span><span class="p">]</span>
            <span class="n">Sxy</span> <span class="o">=</span> <span class="n">errors</span><span class="p">[:</span><span class="n">nx</span><span class="p">,</span> <span class="n">nx</span><span class="p">:]</span>
            <span class="n">Syy</span> <span class="o">=</span> <span class="n">errors</span><span class="p">[</span><span class="n">nx</span><span class="p">:,</span> <span class="n">nx</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span> <span class="o">=</span> <span class="n">errors</span>

        <span class="c1"># Check whether y_is_detected is either [] or an array of booleans the same length as xobs and yobs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="ow">or</span>
            <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jax</span><span class="o">.</span><span class="n">Array</span><span class="p">))</span>
                <span class="ow">and</span> <span class="n">y_is_detected</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">xobs</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;y_is_detected must be either an empty list or a boolean array &quot;</span>
                <span class="s2">&quot;of the same length as xobs and yobs&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">model</span><span class="p">():</span>

            <span class="c1"># Parameters of function</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
                    <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                        <span class="n">p</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">Uniform</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">ImproperUniform</span><span class="p">(</span>
                        <span class="n">dist</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">(),</span> <span class="n">event_shape</span><span class="o">=</span><span class="p">()))</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_default</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">theta</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">pidx</span><span class="p">)])</span>

            <span class="c1"># Â f(x) and f&#39;(x) for these params</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
                <span class="n">G</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">jacrev</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fun</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">)(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fprime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

            <span class="c1"># Â Intrinsic scatter</span>
            <span class="k">if</span> <span class="n">infer_intrinsic</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                        <span class="s2">&quot;sig&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">Uniform</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sig</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;sig&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">ImproperUniform</span><span class="p">(</span>
                        <span class="n">dist</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">positive</span><span class="p">,</span> <span class="p">(),</span> <span class="n">event_shape</span><span class="o">=</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="mf">0.</span>

            <span class="c1"># MNR parameters</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mnr&#39;</span><span class="p">:</span>
                <span class="n">mu_gauss</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;mu_gauss&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">ImproperUniform</span><span class="p">(</span>
                    <span class="n">dist</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">(),</span> <span class="n">event_shape</span><span class="o">=</span><span class="p">()))</span>
                <span class="n">w_gauss</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;w_gauss&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">ImproperUniform</span><span class="p">(</span>
                    <span class="n">dist</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">positive</span><span class="p">,</span> <span class="p">(),</span> <span class="n">event_shape</span><span class="o">=</span><span class="p">()))</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gmm&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gmm_prior</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
                    <span class="n">all_mu_gauss</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;mu_gauss&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">ImproperUniform</span><span class="p">(</span>
                        <span class="n">dist</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">ordered_vector</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="n">ngauss</span><span class="p">,)))</span>
                    <span class="n">all_w_gauss</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;w_gauss&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">ImproperUniform</span><span class="p">(</span>
                        <span class="n">dist</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">positive</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="n">ngauss</span><span class="p">,)))</span>
                    <span class="n">all_weights</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">Dirichlet</span><span class="p">(</span>
                        <span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ngauss</span><span class="p">)))</span>
                <span class="k">elif</span> <span class="n">gmm_prior</span> <span class="o">==</span> <span class="s1">&#39;hierarchical&#39;</span><span class="p">:</span>
                    <span class="n">hyper_mu</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;hyper_mu&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">ImproperUniform</span><span class="p">(</span>
                        <span class="n">dist</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="p">(),</span> <span class="n">event_shape</span><span class="o">=</span><span class="p">()))</span>
                    <span class="n">hyper_w2</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;hyper_w2&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">ImproperUniform</span><span class="p">(</span>
                        <span class="n">dist</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">positive</span><span class="p">,</span> <span class="p">(),</span> <span class="n">event_shape</span><span class="o">=</span><span class="p">()))</span>
                    <span class="n">hyper_u2</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;hyper_u2&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">InverseGamma</span><span class="p">(</span>
                        <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">hyper_w2</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
                    <span class="n">all_mu_gauss</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;mu_gauss&quot;</span><span class="p">,</span> <span class="n">roxy</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">OrderedNormal</span><span class="p">(</span>
                        <span class="n">hyper_mu</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hyper_u2</span><span class="p">)),</span> <span class="n">sample_shape</span><span class="o">=</span><span class="p">(</span><span class="n">ngauss</span><span class="p">,))</span>
                    <span class="n">all_w_gauss</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;w_gauss&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">InverseGamma</span><span class="p">(</span>
                        <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">hyper_w2</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">sample_shape</span><span class="o">=</span><span class="p">(</span><span class="n">ngauss</span><span class="p">,)))</span>
                    <span class="n">all_weights</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="s2">&quot;weights&quot;</span><span class="p">,</span> <span class="n">dist</span><span class="o">.</span><span class="n">Dirichlet</span><span class="p">(</span>
                        <span class="n">jnp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ngauss</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>

            <span class="c1"># Sample</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mnr&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

                    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                        <span class="s1">&#39;obs&#39;</span><span class="p">,</span>
                        <span class="n">roxy</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">Likelihood_MNR_MV</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">Sxx</span><span class="p">,</span> <span class="n">Syy</span><span class="p">,</span> <span class="n">Sxy</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span>
                                                    <span class="n">sig</span><span class="p">,</span> <span class="n">mu_gauss</span><span class="p">,</span> <span class="n">w_gauss</span><span class="p">),</span>
                        <span class="n">obs</span><span class="o">=</span><span class="n">yobs</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                            <span class="s1">&#39;obs&#39;</span><span class="p">,</span>
                            <span class="n">roxy</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">Likelihood_MNR_uplims</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">y_is_detected</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span>
                                                            <span class="n">fprime</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">mu_gauss</span><span class="p">,</span> <span class="n">w_gauss</span><span class="p">),</span>
                            <span class="n">obs</span><span class="o">=</span><span class="n">yobs</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                            <span class="s1">&#39;obs&#39;</span><span class="p">,</span>
                            <span class="n">roxy</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">Likelihood_MNR</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fprime</span><span class="p">,</span>
                                                     <span class="n">sig</span><span class="p">,</span> <span class="n">mu_gauss</span><span class="p">,</span> <span class="n">w_gauss</span><span class="p">),</span>
                            <span class="n">obs</span><span class="o">=</span><span class="n">yobs</span><span class="p">,</span>
                        <span class="p">)</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;unif&#39;</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>

                <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
                    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                        <span class="s1">&#39;obs&#39;</span><span class="p">,</span>
                        <span class="n">roxy</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">Likelihood_unif_MV</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">Sxx</span><span class="p">,</span> <span class="n">Syy</span><span class="p">,</span> <span class="n">Sxy</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span>
                                                     <span class="n">sig</span><span class="p">),</span>
                        <span class="n">obs</span><span class="o">=</span><span class="n">yobs</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                        <span class="s1">&#39;obs&#39;</span><span class="p">,</span>
                        <span class="n">roxy</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">Likelihood_unif</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fprime</span><span class="p">,</span>
                                                  <span class="n">sig</span><span class="p">),</span>
                        <span class="n">obs</span><span class="o">=</span><span class="n">yobs</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;prof&#39;</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>

                <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
                    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                        <span class="s1">&#39;obs&#39;</span><span class="p">,</span>
                        <span class="n">roxy</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">Likelihood_prof_MV</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">Sxx</span><span class="p">,</span> <span class="n">Syy</span><span class="p">,</span> <span class="n">Sxy</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span>
                                                     <span class="n">sig</span><span class="p">,</span> <span class="n">include_logdet</span><span class="o">=</span><span class="n">include_logdet</span><span class="p">),</span>
                        <span class="n">obs</span><span class="o">=</span><span class="n">yobs</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                        <span class="s1">&#39;obs&#39;</span><span class="p">,</span>
                        <span class="n">roxy</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">Likelihood_prof</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fprime</span><span class="p">,</span>
                                                  <span class="n">sig</span><span class="p">,</span> <span class="n">include_logdet</span><span class="o">=</span><span class="n">include_logdet</span><span class="p">),</span>
                        <span class="n">obs</span><span class="o">=</span><span class="n">yobs</span><span class="p">,</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gmm&#39;</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_is_detected</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>

                <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">numpyro</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span>
                        <span class="s1">&#39;obs&#39;</span><span class="p">,</span>
                        <span class="n">roxy</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">Likelihood_GMM</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fprime</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span>
                                                 <span class="n">all_mu_gauss</span><span class="p">,</span> <span class="n">all_w_gauss</span><span class="p">,</span> <span class="n">all_weights</span><span class="p">),</span>
                        <span class="n">obs</span><span class="o">=</span><span class="n">yobs</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="n">rng_key</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">PRNGKey</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">seed</span><span class="p">))</span>
        <span class="n">rng_key</span><span class="p">,</span> <span class="n">rng_key_</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">rng_key</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vals</span><span class="p">,</span> <span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimise</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">,</span> <span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">errors</span><span class="p">,</span> <span class="n">y_is_detected</span><span class="o">=</span><span class="n">y_is_detected</span><span class="p">,</span>
                                                  <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">infer_intrinsic</span><span class="o">=</span><span class="n">infer_intrinsic</span><span class="p">,</span> <span class="n">ngauss</span><span class="o">=</span><span class="n">ngauss</span><span class="p">,</span>
                                                  <span class="n">covmat</span><span class="o">=</span><span class="n">covmat</span><span class="p">,</span> <span class="n">gmm_prior</span><span class="o">=</span><span class="n">gmm_prior</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                                  <span class="n">include_logdet</span><span class="o">=</span><span class="n">include_logdet</span><span class="p">)</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">x</span>
                <span class="n">init</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">param_names</span><span class="p">,</span> <span class="n">vals</span><span class="p">)}</span>
                <span class="k">if</span> <span class="s1">&#39;mu_gauss_0&#39;</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">:</span>
                    <span class="n">init_mu</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span> <span class="o">*</span> <span class="n">ngauss</span>
                    <span class="n">init_w</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span> <span class="o">*</span> <span class="n">ngauss</span>
                    <span class="n">init_weight</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span> <span class="o">*</span> <span class="n">ngauss</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngauss</span><span class="p">):</span>
                        <span class="n">init_mu</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">init</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;mu_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
                        <span class="n">init_w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">init</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;w_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
                        <span class="n">init</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mu_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                        <span class="n">init</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;w_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngauss</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="n">init_weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">init</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;weight_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
                        <span class="n">init</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;weight_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">init_weight</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">init_weight</span><span class="p">)</span>
                    <span class="n">init</span><span class="p">[</span><span class="s1">&#39;mu_gauss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">init_mu</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">gmm_prior</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
                        <span class="n">init</span><span class="p">[</span><span class="s1">&#39;w_gauss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">init_w</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">gmm_prior</span> <span class="o">==</span> <span class="s1">&#39;hierarchical&#39;</span><span class="p">:</span>
                        <span class="n">init</span><span class="p">[</span><span class="s1">&#39;w_gauss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">init_w</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="n">init</span><span class="p">[</span><span class="s1">&#39;weight_gauss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">init_weight</span><span class="p">)</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">init</span><span class="p">[</span><span class="s1">&#39;mu_gauss&#39;</span><span class="p">])</span>
                    <span class="n">init</span><span class="p">[</span><span class="s1">&#39;mu_gauss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">init</span><span class="p">[</span><span class="s1">&#39;mu_gauss&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">init</span><span class="p">[</span><span class="s1">&#39;w_gauss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">init</span><span class="p">[</span><span class="s1">&#39;w_gauss&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">init</span><span class="p">[</span><span class="s1">&#39;weight_gauss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">init</span><span class="p">[</span><span class="s1">&#39;weight_gauss&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="s1">&#39;sig&#39;</span> <span class="ow">in</span> <span class="n">init</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">init</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Setting initial sigma to positive value&#39;</span><span class="p">)</span>
                    <span class="n">init</span><span class="p">[</span><span class="s1">&#39;sig&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.e-5</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">infer</span><span class="o">.</span><span class="n">NUTS</span><span class="p">(</span><span class="n">model</span><span class="p">,</span>
                                        <span class="n">init_strategy</span><span class="o">=</span><span class="n">numpyro</span><span class="o">.</span><span class="n">infer</span><span class="o">.</span><span class="n">initialization</span><span class="o">.</span><span class="n">init_to_value</span><span class="p">(</span><span class="n">values</span><span class="o">=</span><span class="n">init</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Running MCMC&#39;</span><span class="p">)</span>
            <span class="n">sampler</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">infer</span><span class="o">.</span><span class="n">MCMC</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">num_chains</span><span class="o">=</span><span class="n">num_chains</span><span class="p">,</span>
                                         <span class="n">num_warmup</span><span class="o">=</span><span class="n">nwarm</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">nsamp</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span>
            <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">rng_key_</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Could not init to optimised values&#39;</span><span class="p">)</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">infer</span><span class="o">.</span><span class="n">NUTS</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Running MCMC&#39;</span><span class="p">)</span>
            <span class="n">sampler</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">infer</span><span class="o">.</span><span class="n">MCMC</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">num_chains</span><span class="o">=</span><span class="n">num_chains</span><span class="p">,</span>
                                         <span class="n">num_warmup</span><span class="o">=</span><span class="n">nwarm</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="n">nsamp</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">)</span>
            <span class="n">sampler</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">rng_key_</span><span class="p">)</span>

        <span class="n">samples</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_samples</span><span class="p">()</span>

        <span class="c1"># We actually samples w2 if gmm_prior = &#39;hierarchical&#39;, so correct for this</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gmm&#39;</span> <span class="ow">and</span> <span class="n">gmm_prior</span> <span class="o">==</span> <span class="s1">&#39;hierarchical&#39;</span><span class="p">:</span>
            <span class="n">samples</span><span class="p">[</span><span class="s1">&#39;w_gauss&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="s1">&#39;w_gauss&#39;</span><span class="p">])</span>

        <span class="c1"># Print summary</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">sites</span> <span class="o">=</span> <span class="n">samples</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">state_sample_field</span> <span class="o">=</span> <span class="n">attrgetter</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">_sample_field</span><span class="p">)(</span>
                    <span class="n">sampler</span><span class="o">.</span><span class="n">_last_state</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state_sample_field</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">sites</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="n">k</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">samples</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">state_sample_field</span>
                    <span class="p">}</span>
            <span class="n">numpyro</span><span class="o">.</span><span class="n">diagnostics</span><span class="o">.</span><span class="n">print_summary</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">prob</span><span class="o">=</span><span class="mf">0.95</span><span class="p">)</span>
            <span class="n">extra_fields</span> <span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">get_extra_fields</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;diverging&quot;</span> <span class="ow">in</span> <span class="n">extra_fields</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Number of divergences: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">extra_fields</span><span class="p">[</span><span class="s2">&quot;diverging&quot;</span><span class="p">]))</span>
                <span class="p">)</span>

        <span class="c1"># Raise warning if too few effective samples</span>
        <span class="n">neff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">neff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpyro</span><span class="o">.</span><span class="n">diagnostics</span><span class="o">.</span><span class="n">effective_sample_size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">neff</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">numpyro</span><span class="o">.</span><span class="n">diagnostics</span><span class="o">.</span><span class="n">effective_sample_size</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">neff</span> <span class="o">&lt;</span> <span class="mi">100</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bad_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Fewer than 100 effective samples for parameters: &#39;</span>
                          <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bad_keys</span><span class="p">),</span> <span class="n">category</span><span class="o">=</span><span class="ne">Warning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Raise warning if the peak of the posterior is too close to edge of the prior</span>
        <span class="n">bad_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params_to_opt</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
                <span class="n">counts</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">p</span><span class="p">],</span>
                                         <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">param_prior</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">30</span><span class="p">))</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">27</span><span class="p">):</span>
                    <span class="n">bad_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Posterior near edge of prior for parameters: &#39;</span>
                          <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bad_keys</span><span class="p">),</span> <span class="n">category</span><span class="o">=</span><span class="ne">Warning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Raise warning if the second derivative of the function is too big</span>
        <span class="k">if</span> <span class="n">covmat</span><span class="p">:</span>
            <span class="n">xerr</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">errors</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="n">xobs</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xerr</span> <span class="o">=</span> <span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">xerr</span><span class="p">,</span> <span class="s1">&#39;len&#39;</span><span class="p">):</span>
                <span class="n">xerr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xobs</span><span class="p">),</span> <span class="n">xerr</span><span class="p">)</span>
        <span class="c1"># Get medians</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params_to_opt</span><span class="p">]</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_default</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">pidx</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">theta</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">pidx</span><span class="p">)])</span>
        <span class="c1"># Check derivatives</span>
        <span class="n">f2prime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_derivative</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">fprime</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">xobs</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">f2prime</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">fprime</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Â This case is fine</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">xerr</span><span class="p">):</span>
            <span class="n">crit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f2prime</span><span class="p">[</span><span class="o">~</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">xerr</span><span class="p">[</span><span class="o">~</span><span class="n">m</span><span class="p">]</span> <span class="o">/</span> <span class="n">fprime</span><span class="p">[</span><span class="o">~</span><span class="n">m</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">crit</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">nbad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">crit</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Second derivative large for </span><span class="si">{</span><span class="n">nbad</span><span class="si">}</span><span class="s1"> data points&#39;</span><span class="p">,</span>
                              <span class="n">category</span><span class="o">=</span><span class="ne">Warning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">samples</span></div>


<div class="viewcode-block" id="RoxyRegressor.mcmc2opt_index">
<a class="viewcode-back" href="../api.html#regressor.RoxyRegressor.mcmc2opt_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mcmc2opt_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">ngauss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mnr&#39;</span><span class="p">,</span> <span class="n">gmm_prior</span><span class="o">=</span><span class="s1">&#39;hierarchical&#39;</span><span class="p">,</span>
                       <span class="n">infer_intrinsic</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the indices which convert the samples produced by the MCMC to the order</span>
<span class="sd">        required for the optimiser</span>

<span class="sd">        Args:</span>
<span class="sd">            :labels (list): List of label names in the order produced by the MCMC</span>
<span class="sd">            :ngauss (int, default = 1): The number of Gaussians to use in the GMM prior.</span>
<span class="sd">                Only used if method=&#39;gmm&#39;</span>
<span class="sd">            :method (str, default=&#39;mnr&#39;): The name of the likelihood method to use</span>
<span class="sd">                (&#39;mnr&#39;, &#39;gmm&#39;, &#39;unif&#39; or &#39;prof&#39;). See ``roxy.likelihoods`` for more</span>
<span class="sd">                information.</span>
<span class="sd">            :gmm_prior (string, default=&#39;hierarchical&#39;): If method=&#39;gmm&#39;, this decides</span>
<span class="sd">                what prior to put on the GMM componenents. If &#39;uniform&#39;, then the mean</span>
<span class="sd">                and widths have a uniform prior, and if &#39;hierarchical&#39; mu and w^2 have</span>
<span class="sd">                a Normal and Inverse Gamma prior, respectively.</span>
<span class="sd">            :infer_intrinsic (bool, default=True): Whether to infer the intrinsic</span>
<span class="sd">                scatter in the y direction</span>

<span class="sd">        Returns:</span>
<span class="sd">            :param_idx (list): The indices which convert the order of parameters from</span>
<span class="sd">                the MCMC to that expected by the optimiser</span>
<span class="sd">            :param_names (list): The names of the parameters in the order expected by</span>
<span class="sd">                the optimiser</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Now put in order expected by optimisers</span>
        <span class="n">param_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;weights&#39;</span><span class="p">)</span>
                                                              <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;mu_gauss&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;w_gauss&#39;</span><span class="p">)</span>
                                                              <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;sig&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;hierarchical&#39;</span><span class="p">)</span>
                                                              <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;hyper&#39;</span><span class="p">)))]</span>
        <span class="k">if</span> <span class="n">infer_intrinsic</span><span class="p">:</span>
            <span class="n">param_idx</span> <span class="o">=</span> <span class="n">param_idx</span> <span class="o">+</span> <span class="p">[</span><span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;sig&#39;</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gmm&#39;</span><span class="p">:</span>
            <span class="n">param_idx</span> <span class="o">+=</span> <span class="p">[</span><span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mu_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngauss</span><span class="p">)]</span>
            <span class="n">param_idx</span> <span class="o">+=</span> <span class="p">[</span><span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;w_gauss_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngauss</span><span class="p">)]</span>
            <span class="n">param_idx</span> <span class="o">+=</span> <span class="p">[</span><span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;weights_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ngauss</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">gmm_prior</span> <span class="o">==</span> <span class="s1">&#39;hierarchical&#39;</span><span class="p">:</span>
                <span class="n">param_idx</span> <span class="o">=</span> <span class="n">param_idx</span> <span class="o">+</span> <span class="p">[</span><span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;hyper_mu&#39;</span><span class="p">),</span>
                                         <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;hyper_w2&#39;</span><span class="p">),</span>
                                         <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;hyper_u2&#39;</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mnr&#39;</span><span class="p">:</span>
            <span class="n">param_idx</span> <span class="o">=</span> <span class="n">param_idx</span> <span class="o">+</span> \
                <span class="p">[</span><span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;mu_gauss&#39;</span><span class="p">),</span> <span class="n">labels</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;w_gauss&#39;</span><span class="p">)]</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">param_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">param_idx</span><span class="p">,</span> <span class="n">param_names</span></div>


<div class="viewcode-block" id="RoxyRegressor.compute_information_criterion">
<a class="viewcode-back" href="../api.html#regressor.RoxyRegressor.compute_information_criterion">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compute_information_criterion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">criterion</span><span class="p">,</span> <span class="n">params_to_opt</span><span class="p">,</span> <span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span>
                                      <span class="n">errors</span><span class="p">,</span> <span class="n">ngauss</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">infer_intrinsic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                      <span class="n">nwarm</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">nsamp</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mnr&#39;</span><span class="p">,</span> <span class="n">gmm_prior</span><span class="o">=</span><span class="s1">&#39;hierarchical&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">,</span>
                                      <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_logdet</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimiser</span><span class="o">=</span><span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute an information criterion for a given setup</span>
<span class="sd">        If an initial guess is not given, we first run a MCMC</span>
<span class="sd">        to get an initial guess for the maximum likelihood</span>
<span class="sd">        point, and we then an optimsier from this point to get a better</span>
<span class="sd">        estimate for this. Since we do not need good MCMC convergence for this,</span>
<span class="sd">        small values of nwarm and nsamp can be used.</span>

<span class="sd">        Args:</span>
<span class="sd">            :criterion (str): Which information criterion to use (supported: AIC and</span>
<span class="sd">                BIC)</span>
<span class="sd">            :params_to_opt (list): The names of the parameters we wish to optimise</span>
<span class="sd">            :xobs (jnp.ndarray): The observed x values</span>
<span class="sd">            :yobs (jnp.ndarray): The observed y values</span>
<span class="sd">            :errors (jnp.ndarray): [xerr, yerr], giving the error on the observed</span>
<span class="sd">                x and y values</span>
<span class="sd">            :ngauss (int, default = 1): The number of Gaussians to use in the GMM</span>
<span class="sd">                prior. Only used if method=&#39;gmm&#39;</span>
<span class="sd">            :infer_intrinsic (bool, default=True): Whether to infer the intrinsic</span>
<span class="sd">                scatter in the y direction</span>
<span class="sd">            :initial (jnp.ndarray, default=None): The starting point for the optimised.</span>
<span class="sd">                If None, a MCMC is run.</span>
<span class="sd">            :progress_bar (bool, default=True): Whether to display a progress bar for</span>
<span class="sd">                the MCMC</span>
<span class="sd">            :nwarm (int, default=100): The number of warmup steps to use in the MCMC</span>
<span class="sd">            :nsamp (int, default=100): The number of samples to obtain in the MCMC</span>
<span class="sd">            :method (str, default=&#39;mnr&#39;): The name of the likelihood method to use</span>
<span class="sd">                (&#39;mnr&#39;, &#39;gmm&#39;, &#39;unif&#39; or &#39;prof&#39;). See ``roxy.likelihoods`` for more</span>
<span class="sd">                information.</span>
<span class="sd">            :gmm_prior (string, default=&#39;hierarchical&#39;): If method=&#39;gmm&#39;, this decides</span>
<span class="sd">                what prior to put on the GMM componenents. If &#39;uniform&#39;, then the mean</span>
<span class="sd">                and widths have a uniform prior, and if &#39;hierarchical&#39; mu and w^2 have</span>
<span class="sd">                a Normal and Inverse Gamma prior, respectively.</span>
<span class="sd">            :seed (int, default=1234): The seed to use when initialising the sampler</span>
<span class="sd">            :verbose (bool, default=True): Whether to print progress or not</span>
<span class="sd">            :include_logdet (bool, default=True): For the method &#39;prof&#39;, whether to</span>
<span class="sd">                include the normalisation term in the likelihood proportional</span>
<span class="sd">                to log(det(S))</span>
<span class="sd">            :optimiser (str, default=&#39;l-bfgs-b&#39;): The optimiser to use. This must be a</span>
<span class="sd">                method supported by jaxopt.ScipyBoundedMinimize.</span>
<span class="sd">        Returns:</span>
<span class="sd">            :negloglike (float): The optimum negative log-likelihood value</span>
<span class="sd">            :metric (float): The value of the information criterion</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if warning should be raised</span>
        <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">likelihood_warnings</span><span class="p">(</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">infer_intrinsic</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xobs</span><span class="p">),</span> <span class="n">errors</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">initial</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># First run a MCMC to get a guess at the peak, catching the low neff warning</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcmc</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">,</span>
                                    <span class="n">xobs</span><span class="p">,</span>
                                    <span class="n">yobs</span><span class="p">,</span>
                                    <span class="n">errors</span><span class="p">,</span>
                                    <span class="n">nwarm</span><span class="p">,</span>
                                    <span class="n">nsamp</span><span class="p">,</span>
                                    <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                    <span class="n">ngauss</span><span class="o">=</span><span class="n">ngauss</span><span class="p">,</span>
                                    <span class="n">infer_intrinsic</span><span class="o">=</span><span class="n">infer_intrinsic</span><span class="p">,</span>
                                    <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
                                    <span class="n">gmm_prior</span><span class="o">=</span><span class="n">gmm_prior</span><span class="p">,</span>
                                    <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                                    <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                                    <span class="n">include_logdet</span><span class="o">=</span><span class="n">include_logdet</span><span class="p">,</span>
                                    <span class="p">)</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">samples</span> <span class="o">=</span> <span class="n">roxy</span><span class="o">.</span><span class="n">mcmc</span><span class="o">.</span><span class="n">samples_to_array</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
            <span class="n">param_idx</span><span class="p">,</span> <span class="n">param_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mcmc2opt_index</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">ngauss</span><span class="o">=</span><span class="n">ngauss</span><span class="p">,</span>
                                                         <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">gmm_prior</span><span class="o">=</span><span class="n">gmm_prior</span><span class="p">,</span> <span class="n">infer_intrinsic</span><span class="o">=</span><span class="n">infer_intrinsic</span><span class="p">)</span>
            <span class="n">initial</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">samples</span><span class="p">[:,</span> <span class="n">param_idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Run new optimiser</span>
        <span class="n">res</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optimise</span><span class="p">(</span><span class="n">params_to_opt</span><span class="p">,</span>
                               <span class="n">xobs</span><span class="p">,</span>
                               <span class="n">yobs</span><span class="p">,</span>
                               <span class="n">errors</span><span class="p">,</span>
                               <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                               <span class="n">infer_intrinsic</span><span class="o">=</span><span class="n">infer_intrinsic</span><span class="p">,</span>
                               <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span>
                               <span class="n">ngauss</span><span class="o">=</span><span class="n">ngauss</span><span class="p">,</span>
                               <span class="n">gmm_prior</span><span class="o">=</span><span class="n">gmm_prior</span><span class="p">,</span>
                               <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                               <span class="n">include_logdet</span><span class="o">=</span><span class="n">include_logdet</span><span class="p">,</span>
                               <span class="p">)</span>

        <span class="c1"># Count number of parameters and get max-likelihood</span>
        <span class="n">npar</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial</span><span class="p">)</span>
        <span class="n">negloglike</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">fun</span>

        <span class="c1"># Compute criterion</span>
        <span class="k">if</span> <span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;AIC&#39;</span><span class="p">:</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">negloglike</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">npar</span>
        <span class="k">elif</span> <span class="n">criterion</span> <span class="o">==</span> <span class="s1">&#39;BIC&#39;</span><span class="p">:</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">negloglike</span> <span class="o">+</span> <span class="n">npar</span> <span class="o">*</span> <span class="n">jnp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xobs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span>

        <span class="k">return</span> <span class="n">negloglike</span><span class="p">,</span> <span class="n">metric</span></div>


<div class="viewcode-block" id="RoxyRegressor.find_best_gmm">
<a class="viewcode-back" href="../api.html#regressor.RoxyRegressor.find_best_gmm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_best_gmm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params_to_opt</span><span class="p">,</span> <span class="n">xobs</span><span class="p">,</span> <span class="n">yobs</span><span class="p">,</span> <span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">,</span> <span class="n">max_ngauss</span><span class="p">,</span>
                      <span class="n">best_metric</span><span class="o">=</span><span class="s1">&#39;BIC&#39;</span><span class="p">,</span> <span class="n">infer_intrinsic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">progress_bar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nwarm</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                      <span class="n">nsamp</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">gmm_prior</span><span class="o">=</span><span class="s1">&#39;hierarchical&#39;</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">include_logdet</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the number of Gaussians to use in a Gaussian Mixture Model</span>
<span class="sd">        hyper-prior on the true x values, accoridng to some metric.</span>

<span class="sd">        Args:</span>
<span class="sd">            :params_to_opt (list): The names of the parameters we wish to optimise</span>
<span class="sd">            :xobs (jnp.ndarray): The observed x values</span>
<span class="sd">            :yobs (jnp.ndarray): The observed y values</span>
<span class="sd">            :xerr (jnp.ndarray): The error on the observed x values</span>
<span class="sd">            :yerr (jnp.ndarray): The error on the observed y values</span>
<span class="sd">            :max_ngauss (int): The maximum number of Gaussians to consider</span>
<span class="sd">            :best_metric (str): Metric to use to compare fits (supported: AIC and BIC)</span>
<span class="sd">            :infer_intrinsic (bool, default=True): Whether to infer the intrinsic</span>
<span class="sd">                scatter in the y direction</span>
<span class="sd">            :progress_bar (bool, default=True): Whether to display a progress bar for</span>
<span class="sd">                the MCMC</span>
<span class="sd">            :nwarm (int, default=100): The number of warmup steps to use in the MCMC</span>
<span class="sd">            :nsamp (int, default=100): The number of samples to obtain in the MCMC</span>
<span class="sd">            :gmm_prior (string, default=&#39;hierarchical&#39;): If method=&#39;gmm&#39;, this decides</span>
<span class="sd">                what prior to put on the GMM componenents. If &#39;uniform&#39;, then the mean</span>
<span class="sd">                and widths have a uniform prior, and if &#39;hierarchical&#39; mu and w^2 have</span>
<span class="sd">                a Normal and Inverse Gamma prior, respectively.</span>
<span class="sd">            :seed (int, default=1234): The seed to use when initialising the sampler</span>
<span class="sd">            :verbose (bool, default=True): Whether to print progress or not</span>
<span class="sd">            :include_logdet (bool, default=True): For the method &#39;prof&#39;, whether to</span>
<span class="sd">                include the normalisation term in the likelihood proportional</span>
<span class="sd">                to log(det(S))</span>

<span class="sd">        Returns:</span>
<span class="sd">            :ngauss (int): The best number of Gaussians to use according to the metric</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if warning should be raised</span>
        <span class="n">roxy</span><span class="o">.</span><span class="n">likelihoods</span><span class="o">.</span><span class="n">likelihood_warnings</span><span class="p">(</span>
            <span class="s1">&#39;gmm&#39;</span><span class="p">,</span> <span class="n">infer_intrinsic</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xobs</span><span class="p">),</span> <span class="p">[</span><span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">metric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">max_ngauss</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ngauss</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_ngauss</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span><span class="o">*</span><span class="mi">20</span><span class="p">,</span>
                  <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Starting ngauss=</span><span class="si">{</span><span class="n">ngauss</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span><span class="o">*</span><span class="mi">20</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">metric</span><span class="p">[</span><span class="n">ngauss</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_information_criterion</span><span class="p">(</span>
                <span class="n">best_metric</span><span class="p">,</span>
                <span class="n">params_to_opt</span><span class="p">,</span>
                <span class="n">xobs</span><span class="p">,</span>
                <span class="n">yobs</span><span class="p">,</span>
                <span class="p">[</span><span class="n">xerr</span><span class="p">,</span> <span class="n">yerr</span><span class="p">],</span>
                <span class="n">ngauss</span><span class="o">=</span><span class="n">ngauss</span><span class="p">,</span>
                <span class="n">infer_intrinsic</span><span class="o">=</span><span class="n">infer_intrinsic</span><span class="p">,</span>
                <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
                <span class="n">nwarm</span><span class="o">=</span><span class="n">nwarm</span><span class="p">,</span>
                <span class="n">nsamp</span><span class="o">=</span><span class="n">nsamp</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s1">&#39;gmm&#39;</span><span class="p">,</span>
                <span class="n">gmm_prior</span><span class="o">=</span><span class="n">gmm_prior</span><span class="p">,</span>
                <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
                <span class="n">include_logdet</span><span class="o">=</span><span class="n">include_logdet</span><span class="p">)</span>

        <span class="n">ngauss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Best ngauss according to </span><span class="si">{</span><span class="n">best_metric</span><span class="si">}</span><span class="s1">:&#39;</span><span class="p">,</span> <span class="n">ngauss</span><span class="p">)</span>
            <span class="n">metric</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ngauss</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Deaglan Bartlett and Harry Desmond.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>